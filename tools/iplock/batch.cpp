// Copyright (c) 2014-2022  Made to Order Software Corp.  All Rights Reserved
//
// https://snapwebsites.org/project/iplock
// contact@m2osw.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.


/** \file
 * \brief batch tool.
 *
 * This implementation offers a way to easily and safely add and remove
 * IP addresses one wants to block/unblock temporarily.
 *
 * The tool makes use of the iptables tool to add and remove rules
 * to one specific table which is expected to be included in your
 * INPUT rules (with a `-j \<table-name>`).
 */


// self
//
#include    "batch.h"

#include    "flush.h"
#include    "scheme.h"


// snapdev
//
#include    <snapdev/mkdir_p.h>
#include    <snapdev/string_replace_many.h>


// libaddr
//
#include    <libaddr/addr_parser.h>


// C++
//
#include    <iostream>
#include    <fstream>
#include    <sstream>


// C
//
#include    <stdio.h>


// last include
//
#include    <snapdev/poison.h>



namespace tool
{



/** \class batch
 * \brief Block the specified IP addresses.
 *
 * This class goes through the list of IP addresses specified on the
 * command line and add them to the chain as defined in ipconfig.conf.
 *
 * By default, the scheme is set to "http". It can be changed with
 * the --scheme command line option.
 */



batch::batch(iplock * parent, advgetopt::getopt::pointer_t opts)
    : command(parent, "iplock --batch", opts)
    , f_ip_addr_filename(opts->get_string("batch"))
{
}


batch::~batch()
{
}


void batch::run()
{
    typedef std::vector<std::string>        ip_list_t;
    typedef std::map<std::string,ip_list_t> scheme_map_t;

    scheme_map_t scheme_map;

    // First, read the input file. The format for each line is:
    // [ip_address] [scheme]
    //
    {
        std::ifstream ip_addrs(f_ip_addr_filename);
        if(!ip_addrs)
        {
            std::cerr
                << "error:iplock: cannot open \""
                << f_ip_addr_filename
                << "\".\n";
            exit(1);
        }

        for(int line_num = 0; !ip_addrs.eof(); ++line_num)
        {
            std::string line;
            std::getline(ip_addrs, line);

            if(line[0] == '#' || line.empty())
            {
                // Ignore comments and empty lines
                continue;
            }

            std::string::size_type const space(line.find(' '));
            if(std::string::npos == space)
            {
                std::cerr
                    << "error:iplock:"
                    << f_ip_addr_filename
                    << ':'
                    << line_num
                    << ": an IP address followed by a scheme is required [invalid line='"
                    << line
                    << "'].\n";
                exit(1);
            }

            std::string const addr(line.substr(0, space));
            std::string const scheme (line.substr(space + 1));

            if(scheme.empty())
            {
                std::cerr
                    << "error:iplock:"
                    << f_ip_addr_filename
                    << ':'
                    << line_num
                    << ": an IP address is followed by an empty scheme [invalid line='"
                    << line
                    << "'].\n";
                exit(1);
            }

            scheme_map[scheme].push_back(addr);
        }
    }

    // Next, flush all of the rules for the "unwanted" table.
    //
    flush fl(f_iplock, f_opts, "iplock --batch");
    fl.run();

    // Then, create the output folder and iplock file.
    //
    std::string const cache_folder(f_iplock_opts->get_string("batch_cache"));
    snapdev::mkdir_p(cache_folder, false, 0700, "iplock", "iplock");

    std::stringstream ss;
    ss << cache_folder << "/iplock-" << getpid() << ".rules";
    std::string const outfile(ss.str());

    // Open the output rules file.
    //
    std::ofstream rules(outfile);
    rules << "# Generated by iplock\n"
          << "*filter\n"
          << ":" << f_chain << " - [0:0]\n";

    // Now iterate through the schemes and process each IP address in that scheme.
    //
    for(auto const & pair : scheme_map)
    {
        ip_list_t const & ip_list(pair.second);

        // Read the scheme object for the current scheme.
        //
        scheme const sme(f_iplock, "iplock --batch", f_opts, pair.first);
        std::string const options(sme.get_scheme_string("batch"));

        // Iterate through all of the ip addresses, and each specified port.
        //
        for(auto const & ip_addr : ip_list)
        {
            // TODO: support multi-port functionality (i.e. run this loop
            //       with blocks of 15 ports instead of one rule per port)
            //
            for(auto const port : sme.get_ports())
            {
                // Concatenate the rule to the rules file.
                //
                //-A unwanted -s 3.1.1.1/32 -i eth0 -p tcp -m tcp --dport 80 -j DROP
                //-A unwanted -s 3.1.1.1/32 -i eth0 -p tcp -m tcp --dport 443 -j DROP
                //
                std::string rule_options(snapdev::string_replace_many(options, {
                                { "[command]",   "" },
                                { "[chain]",     f_chain },
                                { "[port]",      std::to_string(static_cast<unsigned int>(port)) },
                                { "[ip]",        ip_addr },
                                { "[interface]", f_interface },
                            }));

                rules << rule_options << std::endl;
            }
        }
    }

    // Append footer, flush and close the file.
    //
    rules << f_iplock_opts->get_string("batch_footer") << '\n';
    rules.flush();
    if(!rules)
    {
        std::cerr
            << "error:iplock: error(s) happened while generating rules file \""
            << outfile
            << "\". Please verify that iplock has enough permissions to create the file and that the destination folder exists.\n";
        exit(1);
    }
    rules.close();

    // Get batch command and call it with our new file as argument.
    //
    std::stringstream fullcmd;
    fullcmd << f_iplock_opts->get_string("batch")
            << ' '
            << outfile;

    // If user specified --quiet, ignore all output.
    //
    if(f_quiet)
    {
        fullcmd << " 1>/dev/null 2>&1";
    }

    // If user specified --verbose, show the command being run.
    //
    if(f_verbose)
    {
        std::cout << fullcmd.str() << std::endl;
    }

    // Run the rules restore command.
    //
    int const rc(system(fullcmd.str().c_str()));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wold-style-cast"
    if(!WIFEXITED(rc))
    {
        if(!f_verbose)
        {
            // if not verbose, make sure to show the command so the
            // user knows what failed
            //
            int const save_errno(errno);
            std::cerr << fullcmd.str() << std::endl;
            errno = save_errno;
        }
        perror("error:iplock: netfilter command failed");

        f_exit_code = 1;
    }
#pragma GCC diagnostic pop

#ifndef _DEBUG
    // Only remove if we are not in debug mode
    //
    unlink(outfile.c_str());
#endif
}



} // namespace tool
// vim: ts=4 sw=4 et
